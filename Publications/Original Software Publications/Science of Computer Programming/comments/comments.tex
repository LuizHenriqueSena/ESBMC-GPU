\documentclass[12pt]{article}

\usepackage[normalem]{ulem}
\usepackage{xcolor}

%please, use \sout{} to indicate that a comment has been implemented

\begin{document}

\setcounter{secnumdepth}{0}

\section{Reviews}

\subsection{Reviewer \#1}

\subsubsection{Summary}

The authors present an extension of the ESBMC tool, to verify CUDA GPU kernels by means of bounded model checking. This is an interesting and relevant topic, since GPUs are used increasingly often to speed up applications significantly. However, programming GPU software can be very tedious and error-prone. A formal verifier of GPU code can make the development process much more efficient.

\subsubsection{Comments}

\begin{itemize}
\item The present submission provides an ok overview of the capabilities of the tool, in my opinion, but the authors never really address the details to fully understand what the tool can and cannot do. For instance, when discussing the experimental evaluation, it is not explained what the source of the bugs is in the various benchmarks.
  \begin{itemize}
  \item Are there clear differences in the types of bugs that the different tools being compared can detect?
  \item Which types could ESBMC-GPU handle in particular better than the other tools, and why?
  \item To what extent does ESBMC-GPU support CUDA?
  \item Can ESBMC-GPU handle variables in different types of memory?
  \item (Shared, global, thread registers?), and inter-warp communication, for instance?
  \item In that respect, what does COM cover, and what remains to be added?
  \item Is the memory model for the different types of memory complete?
  \end{itemize}

\item Another paragraph that raises questions is the second on page 3. It seems to say that COM uses pthread functions to simulate GPU kernels. Is that so, and why is it necessary to simulate them? Is this safe to do, because some features in CUDA are not available in C/C++. How do the authors handle those, or do they not?

\item At some point, the authors mention in passing that Microsoft C++ AMP projects have been used for the evaluation. Does this mean that this language is also supported, or are the benchmarks translated?

\item Concluding, I would like to see an overall more detailed discussion of the capabilities of the tool.

\end{itemize}

\subsubsection{Detailed comments:}

\begin{itemize}
\item Page 2
  \begin{itemize}
  \item \sout{space-state exploration $\rightarrow$ state-space exploration;}
  \item \sout{ESBMC-GPU builds on top of ESBMC $\rightarrow$ ESBMC-GPU is built on top of ESBMC;}
  \end{itemize}
\item Page 3
  \begin{itemize}
  \item consists in $\rightarrow$ consists of;
  \item Besides, in: remove ``Besides'';
  \item reduce state space $\rightarrow$ reduce the state space;
  \end{itemize}
\item Page 4
  \begin{itemize}
  \item if multiple threads perform unsynchronized 90 access to shared-memory locations: to the same memory locations, it is crucial to mention that;
  \item has been systematically explored $\rightarrow$ have been systematically explored;
  \item Therefore: the next conclusion does not follow logically from the previous statements, so ``therefore'' should be removed here;
  \end{itemize}
\item Page 5
  \begin{itemize}
  \item Figure 2: between lines 17 and 18, the contents of {\tt dev\_a} should be copied to a with a {\tt cudaMemcpy}, otherwise the subsequent check is quite useless;
  \end{itemize}
\item Page 6
  \begin{itemize}
  \item In addition $\rightarrow$ On the other hand;
  \item Besides, it further simplifies verification models: further compared to what? How does it make it easier?
  \item if compared: remove ``if'';
  \item stream interleaving: what is this?
  \item  to reduce the number of thread interleavings: in what respect? Not reducing the number of threads, right? You already use the 2-thread simplification;
  \end{itemize}
\end{itemize}

\end{document}