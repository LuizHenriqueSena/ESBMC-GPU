#######################################################

ESBMC-GPU is executed with:

	esbmc file.cu + <test.desc_content>

Before this, replace the kernel call by the respective ESBMC_verify_kernel() function using 1 block and 2 threads per block. Ex: replace kernel <<<64,128>>> by ESBMC_verify_kernel(kernel,1,2)

Ex:
	esmbc file.cu  --force-malloc-success --context-switch 2 --I libraries

--data-races-check --no-bounds-check
#######################################################

To the verification of GPUVerify, the following modifications are required:
(a) remove the mainfunction;
(b) check if the variable initialization performed by the main function is responsible for controlling some conditional declaration inside the kernel; if so, such variable must be initialized by requires() function;
(c) check if there is any assertion in the kernel; if so, this assertion must be replaced by __assert();
(d) check if there are specific functions to C/C++ libraries; if so, they must be removed, as they are not supported by GPUVerify.

To run GPUVerify, two options must be used: --gridDim=M and --blockDim=N to assign the number of blocks and threads (per block),respectively.

Call GPUVerify as:
	gpuverify file.cu --blockDim=2 --gridDim=1.

If you wanna check array out-of-bounds, add --check-array-bounds on command line.

#######################################################
Additional options for ESBMC-GPU and GPUVerify are necessary to check for data races and array out-of-bounds, respectively.

#######################################################
To use PUG:

(a) the file extension must be changed from “.cu” to “.c”;
(b) given that PUG is unable to verify main functions, these must be removed, in order to keep the kernel function only;
(c) PUG’s proprietary libraries my cutil.h and config.h must be called inside the “.c” file;
(d) The kernel function’s name has to be renamed to “kernel”. 

Call PUG as: 
	pug kernel.c.


#######################################################
With GKLEE, use two commands: gklee-nvcc and gklee.

The first one checks the file to be verified, with the extension “.cu”. When this command is executed, two new files are generated: a “.cpp” file and a runnable file (without extension). Then, the second command is used with the runnable file. 

Call GKLEE as:
	gklee-nvcc file.cu -libc=uclibc
or 
	gklee-nvcc file.cu -libc=klee

Test both and choose the best option and
	gklee file


#######################################################
with CIVL, use the command 
	civl verify file.cu. 

If the benchmark contains the malloc and free functions, manually add the standard ANSI-C library stdlib.h to the CUDA program, although it is not mandatory to declare it according to the CUDA documentation.
