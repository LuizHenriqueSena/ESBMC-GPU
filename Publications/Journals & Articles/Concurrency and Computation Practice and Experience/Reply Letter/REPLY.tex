\documentclass[11pt]{article}

\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{url}
%\usepackage{mathtools}
\usepackage{enumerate}
\usepackage[nodayofweek]{datetime}

%\mathtoolsset{showonlyrefs}

\usepackage{xcolor}
%\input{rgbcolors}
%\usepackage{color}
\usepackage{natbib}
% \usepackage[style=authoryear-comp,dashed=false]{biblatex}
% \bibliography{piecewise_lyapunov}
\newcommand{\Real}{\mathbb{R}}

%\definecolor{DarkGreen}{rgb}{0.2, 0.4, 0.2}



\textwidth 15cm
\setlength{\textheight}{1.1\textheight}
\newcommand\hi{\hspace*{\parindent}}
\newcommand\vi{\vspace{\baselineskip}}
\newcommand\lac{{\mbox{{\Huge\bf L}\hspace{-0.65em}
\raisebox{-1.2ex}{\Huge\bf A}\hspace{-1.1em}
\raisebox{-0.6ex}{\Huge\bf C~}}}}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\lhead{Manuscript Reference Number: CPE-16-0056}
\rhead{Page \thepage\ of \pageref{LastPage}}
\lfoot{}
\rfoot{}

%\pagestyle{headings}
\pagenumbering{roman}
\begin{document}
\setcounter{page}{1}
\thispagestyle{empty}


\hoffset -1.5cm \voffset .5cm


\sf

\vspace*{-2.5cm} \hspace*{-0.1cm} {\small
{\mbox{\begin{minipage}{1.5cm}
\centerline{\includegraphics[width=1.8cm]{logo_ufam.png}}
\end{minipage}}} \hspace*{0.5cm}
\begin{minipage}{11.0cm}{\sf \large \textbf{FEDERAL UNIVERSITY OF AMAZONAS}}\\
{\sc Department of Electronics and Computing}
\end{minipage}
} \vspace*{0mm}

\hspace*{-.7cm} {\rule[-1ex]{15cm}{0.03cm}}

\vi \vi
\begin{flushright}
\begin{minipage}{7.0cm}\small
{\bf Please Reply to:}\\
Dr. Lucas C. Cordeiro\\
Federal University of Amazonas\\
Department of Electronics and Computing\\
Avenida General Rodrigo Ot\'avio, 6200, Coroado\\
69077-000 - Manaus - AM - BRAZIL\\
{\em e-mail: lucascordeiro@ufam.edu.br}
\end{minipage}
\end{flushright}

\vi \vi
\hspace*{\fill}{\small Manaus, June 2, 2016.}
\vi \vi


\hoffset -1.5cm \voffset .5cm

\begin{flushleft}
Dr. Alfredo Goldman\\
   Editor\\
   Concurrency and Computation: Practice and Experience
    \end{flushleft}
\vi

\begin{flushleft}
\textbf{REF.:} CPE-16-0056
    \end{flushleft}
\vi \vi
 
\indent Dear Dr. Goldman,
\vi 

We thank you for asking us to comply with the Referees' reports. We are submitting the revised version of our paper entitled as ``{\em SMT-Based
Context-Bounded Model Checking for CUDA Programs}''  by Phillipe Pereira, Higo Albuquerque, Isabela da Silva, Hendrio Marques, Felipe Monteiro, Ricardo dos Santos, and Lucas Cordeiro.


The details of all changes made to our paper and also our response to each point raised by the reviewers have been included at the end of this letter.



%\vi

%Thank you very much in advance.

\vi\vi

\indent
~~~~~~~~~~~~~~~~~~~~~~~~~~~Sincerely,\\



\begin{quote}
\begin{quote}
\begin{flushright}


\vi
\vi

Lucas C. Cordeiro~~~~~~~
\end{flushright}
\end{quote}
\end{quote}

\hoffset -1.5cm \voffset .5cm


% =============================================
\newpage
\subsection*{Authors'   Response to the Review Comments on manuscript ``{SMT-Based Context-Bounded Model Checking for CUDA Programs}'' -- Manuscript Reference Number: CPE--16--0056}

\vi

The authors thank the anonymous reviewers for their valuable and constructive comments, which helped us improve significantly the quality of our manuscript. 

\vi

According to the reviewers comments, our manuscript has been carefully revised and the detailed changes are highlighted in blue color along the original text. Our responses to all comments, which were raised by the reviewers, are given in the sequel using the blue color.

\vi

We hope that these revisions in the manuscript and our responses will be sufficient to make our manuscript suitable for publication in the Journal of Concurrency and Computation: Practice and Experience.


%\subsection*{Editor-in-Chief comments:}

%\begin{quote}
%The reviewers generally agree that the paper contains some potentially publishable results. They also mention a number of technical issues. The paper should be carefully revised by well addressing all these issues mentioned by the reviewers.
%%The review of this paper is now complete, and I am including the Reviewers' reports (directly at the end of this email and sometimes as attachments).  As you can see, one Reviewer recommends rejection, and the others recommend possible reconsideration after minor revisions. If you are able to revise the manuscript thoroughly in response to the Reviewers' comments, I believe that it would be suitable for second review.  I should add that, in view of the strong criticisms, anything but a thorough response and revision would just be an unfortunate waste of time.
%\end{quote}

%\subsection*{Answer to the Editor-in-Chief comments:}

%Thanks for the AE's   comments. Following six reviewers'  comments and
%suggestions, the manuscript has been significantly revised and rewritten to deal with the technical issues arose by reviewers.
%Following the suggestions of the reviewers, the results have been extended to handle a more general class of agents, namely, we have extended the model of the agent from high-order integrator dynamics to any linear or linearizable system. This has been made possible by the explicit need to provide results in a more general practical application, as was requested by the reviewers. Nevertheless, the methodology proposed still remains the same.
%For more details, refer to the  replies to reviewers'  comments and the revised manuscript.


% =============================================
%\newpage

\vspace*{1cm}

%\subsection*{Associate Editor Comments}

%It was not that easy to make a final decision for this article. Reading the reviews, it becomes clear that the reviewers were not at all happy with the article, so that rejecting the article would be justified. However, a lot of the criticism is because of the presentation, and the unclarity of the added values, while the experimental results attracted the interest of all reviewers. I therefore suggest a major revision and hope that the authors can improve the presentation of their article based on the given reviews.

%The first reviewer recommended a rejection of the article. The main arguments for that recommendation are lack of detail of the verification method, and therefore the impossibility of checking its correctness by a reviewer. Moreover, there was some criticism on the presentation and references made in the article.

%The second reviewer recommends a minor revision, but when reading the review, I found some hard critiques: It seems to me that the reviewer was impressed by the experimental results, but has not seen new verification methods in the article. The main contribution seen by that reviewer is to deal with modeling uncertainty and the effect of finite precision arithmetic in one tool that uses BMC as the core verification techniques and its interesting experimental results.

%The third reviewer recommends a major revision, and complains about unclarity of the technical contributions of the paper and the absence of technical details like the first reviewer.

%The fourth reviewer recommends a major revision, and explains in detail what should be changed with the article. The role of bounded model checking seems also to be pretty unclear.


%\subsection*{Response to Associate Editor}


% =============================================
%\newpage

\vspace*{1cm}

\vi
\subsection*{Reviewer \#1 comments followed by the authors' answers:}

\begin{quote}

{\bf Comments to the Authors}

This paper extends the ESBMC bounded model checker to support CUDA constructs and simulate the execution of CUDA programs in the CPU. Specifically, it models CUDA APIs using usual CPU functions that can be processed by the existing ESBMC checker, and turns GPU threads into CPU threads that are examined and optimized by the ESBMC checker.

This paper's main contributions include: (a) a set of CUDA API models based on CUDA's semantics, (b) the application of a partial order reduction algorithm to curb the thread interleaving explosion issue. In addition, the authors performed a quite comprehensive comparison of their tool ESBMC-GPU with other existing GPU verifiers and checkers.

It is interesting to see how to extend a Pthread-based bounded model checker to handing a different parallel programming model like CUDA. In general, the extension needs to address two main challenges:

  (A) model the data structures and the APIs in the new programming model;
  (B) resolve the difference between PThread and CUDA (i.e. handle the inherent characteristics of how threads are executed and synchronized).

It seems to me that the authors did a good job in (A), e.g. the model of dim3, cudaMalloc, cudaMemcpy, and cudaFree. The model is written to cater for the need of the ESBMC checker. With the model, ESBMC can check CUDA programs like Pthread programs.

\begin{quote}
\textcolor{blue}{\textbf{Response:} We really appreciate the reviewer's summary about our work, which fairly describes the main contributions of our manuscript.}
\end{quote}

{\bf Reviews:}

{\bf (1)} However, the second challenge is handled less swiftly. In the proposed method, each CUDA thread is mapped to a Pthread (in ESBMC). This is fine since the official CUDA simulator uses a similar approach. The main problem is on thread synchronization. CUDA uses lock-step execution within warps (as mentioned in the paper on Page 12), and barrier synchronization within blocks. In contrast, Pthread uses schemes such as mutexes, wait-notification, etc. Bridging the gap between these two different synchronization schemes is tricky. Unfortunately I didn't see how the authors address this gap carefully. They should give some formal descriptions and examples to illustrate that ESBMC-GPU can preserve the CUDA's synchronization scheme precisely.

\begin{quote}
\textcolor{blue}{\textbf{Response:} Actually, each CUDA thread is mapped to a thread using the internal representation of ESBMC (via Pthread library). As pointed out by the reviewer, the thread representation of ESBMC follows a similar approach to the official CUDA simulator. One feature of CUDA related to thread synchronization supported by ESBMC-GPU is the \emph{\tt \_\_syncthreads()} intrinsic function, which specifies synchronization points in the GPU kernel. Such alternative guarantees that all threads in a certain block wait before any of them is allowed to proceed. As described in Algorithm $7$, we implement this feature in our operational model using Pthread functions. First of all, a $count$ global variable is initialized to control how many times the \emph{\tt syncthreads} function is actually called. In its first call, a mutex is initialized and a condition variable is set up (steps from $2$ to $5$ of Algorithm $7$). Then, on each subsequent call, the $count$ variable is incremented (step $6$) and the calling thread is put on hold until it receives a signal (step $8$). When all GPU threads are on hold, the $pthread\_cond\_signal$ function sends a signal to all threads waiting on a specific condition variable (step $9$) and the mutex is then unlocked (step $10$). We address this important discussion in Section 3.2.1. about ``Thread Synchronization'' by describing the \emph{\tt syncthreads} algorithm.}
\end{quote}

{\bf (2)} The proposed Monotonic Partial Order Reduction (MPOR) method deserves more investigation and details. First of all, an existing GPU checker GKLEE checks whether the threads access the same memory location and uses this information to execute only one thread interleaving called canonical schedule. It won't incur any unnecessary thread interleavings, while the proposed MPOR may still explore these interleavings. In other words, GKLEE has implemented, with respect to the CUDA model, what MPOR try to achieve. So do other GPU verifiers like GPUVerify and PUG (which explore one thread interleaving of two symbolic threads).

\begin{quote}
\textcolor{blue}{\textbf{Response:} We have now considerably improved the MPOR section by describing its reduction and the main differences between our technique and GKLEE canonical scheduling, as pointed out by the reviewer (see Section 3.3.1. about ``Differences from MPOR to other interleaving reduction methods''). There are some sublte differences between both approaches, as described in Sections 3.3.1 and 2.2, where we also compare to GPUVerify and PUG.}
\end{quote}

{\bf (3)} Second, it is unclear how new the MPOR is. It seems to me that the authors directly reuse the MPOR algorithm already included in ESBMC [23].

\begin{quote}
\textcolor{blue}{\textbf{Response:} We have highlighted our improvements to the MPOR algorithm implemented in ESBMC. In particular, we have modified the MPOR algorithm to identify transitions between threads that accessed different memory locations in the same array, where the previous MPOR implementation of ESBMC was unable to handle it. In addition, we have improved the description about the MPOR reduction process in Section 3.3 by adding (1) more details about the algorithm steps and (2) some examples of the algorithm's execution.}
\end{quote}

{\bf (4)} Third, while GKLEE and other existing tools explores only one thread interleaving, it is unclear how many interleavings are explored by ESBMC+MPOR although the authors show that the performance is boosted significantly with the MPOR optimization.

\begin{quote}
\textcolor{blue}{\textbf{Response:} MPOR techniques explores all (possible) interleavings that produce new program states; it builds an SMT formula, for a given interleaving, only when the MPOR analysis is concluded to avoid checking redundant states. Thus, the verification time is directly affected by the size of this formula and its satisfiability checking by a particular SMT solver. In addition, it is worth notice that GKLEE explores schedules of full thread execution in a barrier interval without interleaving statements, while ESBMC-GPU employs BMC and Pthread using MPOR.}
\end{quote}

{\bf (5)} The experimental result part is perhaps the most valuable one in this paper. Experimental results show that ESBMC-GPU is able to detect more properties violations than other existing GPU verifiers, while keeping lower rates of false results. This indicates that the proposed approach merits being published. However this part can be improved as well. Particularly, the authors of this paper should contact the authors of other tools to make sure (1) the right configurations are used; (2) the assumptions for these tools to run properly are satisfied; (3) confirm that the findings (e.g. the false positives and false negatives) are real. For example, Page 15 mentions "GKLEE has 24 benchmarks that were not supported, which are due to the use of the memset function, which is a specific function of the C/C++ libraries".
In fact GKLEE supports most of the C/C++ library functions; but the option ``-libc'' may need to be set properly so as to link the definitions of the C/C++ library functions including memset. With this, GKLEE supports all the benchmarks while the proposed ESBMC-GPU doesn't support 23.

\begin{quote}
\textcolor{blue}{\textbf{Response:} In our (first) submission to CPE, we had previously contacted all authors of the GPU verifiers that we used in our experimental evaluation. However, only the developers of GPUVerify (Dr. Alastair Donaldson) and CIVL (Dr. Stephen Siegel) have replied to our email (we still keep those exchanged emails). The developers of GKLEE and PUG did not reply to our email, which thus makes it difficult to set the most appropriate configuration parameters for those tool. We thank the reviewer for point out the right configuration for GKLEE. We have now re-run GKLEE using the option ``-libc'', as recommended by the reviewer, and then updated the experimental results accordingly. However, even running GKLEE with the option ``-libc'', GKLEE is unable to verify all benchmarks, as reported in Section 4.3. about the ``Experimental Results''. Additionally, all verification results were carefully analyzed by GPU experts in order to confirm the encountered false positives and false negatives.}
\end{quote}

{\bf (6)} Finally, the presentation of the paper can be improved. Despite including the new materials, it is still in a workshop format. Specifically, more space should be given to the CUDA synchronization modeling and the detailed description of MPOR.

\begin{quote}
\textcolor{blue}{\textbf{Response:} According to all reviewers' comments, we believe we have considerably improved the presentation of our manuscript by adding more details about the ESBMC tool architecture (including the link between CUDA operational model and ESBMC), the CUDA operational model (and its organization), the MPOR implementation (including the one-schedule mechanism), and the experimental evaluation (using the most appropriate configuration parameters and benchmarks description). Additionally, we have substantially expanded the number of references in our manuscript to fairly describe the most up-do-date related studies; in particular, we have added approximately $23$ new references to our manuscript, which substantially increased the total number of references to $46$.}
\end{quote}

{\bf (7)} strength

\begin{itemize}
\item Reuse the existing ESBMC to perform bounded model checking on mutli-thread programs
\item Provide a set of CUDA API models for ESBMC
\item Evaluate extensively the tool and compare it with other existing tools
\item Achieve good evaluation results
\end{itemize}

\begin{quote}
\textcolor{blue}{\textbf{Response:} We appreciate the reviewer's effort to highlight the strengths of our manuscript.}
\end{quote}

{\bf (8)} weakness:

\begin{itemize}
\item Do not describe how many CUDA APIs are modeled and how other important APIs are modeled

\begin{quote}
\textcolor{blue}{\textbf{Response:} We support most CUDA Driver and CUDA Runtime APIs; in particular, ESBMC-GPU supports the CUDA call kernel (\textit{device\_launch\_parameters} and \textit{vector\_types}), driver\_types (\textit{math\_functions}, \textit{cuda\_runtime\_api}, and \textit{host\_definitions}), sm\_atomic\_functions (\textit{vector\_types}), and curand\_kernel (curand). We address this important discussion in Section 3.1. about ``Operational Models for CUDA Libraries''.}
\end{quote}

\item Do not address the thread synchronization scheme in CUDA
\item Do not elaborate the MPOR mechanism
\item Lack of awareness of existing tools' one-schedule mechanism (that beats MPOR)
\item Inconclusive experimental comparisons with existing tools
\end{itemize}

\begin{quote}
\textcolor{blue}{\textbf{Response:} We have tackled each point, as aforementioned in the previous questions (from 1 to 6).}
\end{quote}

\end{quote}
		
%--------------------------------------------------------------------
	
\newpage

\subsection*{Reviewer \#2 comments followed by the authors' answers:}
\begin{quote}

{\bf Comments to the Authors}

In this paper the authors present ESBMC-GPU, which is an extension to the Efficient SMT-Based Context-Bounded Model Checker (ESBMC) tool aimed at verifying SMT programs written for the CUDA framework. This paper is an extension of a previous paper published in a conference, and the authors claim that the version of ESBMC-GPU presented in this paper has been optimized and extended when compared to previous versions. All in all, the paper is well written and the results presented are consistent and sound. Yet, the detailed description of the tool and the writing of the paper can be improved to better reflect the optimizations presented in this work. Some comments and suggestions are below:

\begin{quote}
\textcolor{blue}{\textbf{Response:} We appreciate the reviewer's comments. We have carefully revised our manuscript considering all valuable and constructive comments/suggestions.}
\end{quote}

{\bf Reviews:}

{\bf(1)} The abstract can be considerably improved. The contributions of this paper should be highlighted at the abstract.

\begin{quote}
\textcolor{blue}{\textbf{Response:} The abstract was substantially revised, in order to give more emphasis on the main contributions of our manuscript. Additionally, we have now included more details about the experimental results.}
\end{quote}

{\bf(2)} The authors should mention, in the Introduction, that the ESBMC-GPU tool is available for download. The authors mention this possibility in a footnote at section 4.1, but it is important to highlight this possibility at the Introduction.

\begin{quote}
\textcolor{blue}{\textbf{Response:} We have now highlighted in the introduction section that readers (or users) can download our tool and all benchmarks from http://esbmc-gpu.org/ webpage.}
\end{quote}

{\bf(3)} At subsection 2.1, the description of ESBMC should be augmented and improved. Only to illustrate this point, the authors do not even clarify what the acronym ?VC? means.

\begin{quote}
\textcolor{blue}{\textbf{Response:} We have augmented and considerably improved the description of ESBMC according to the reviewer comments. In particular, we have defined the acronym VC and its interpretation; we have also described in more details the (most up-to-date) ESBMC software architecture and the link between CUDA operational model and ESBMC.}
\end{quote}

{\bf(4)} It is important, to improve readability, to include a figure presenting ESBMC-GPU architecture. It is also important to use this figure to improve the discussion on architectural differences to the original ESBMC tool.

\begin{quote}
\textcolor{blue}{\textbf{Response:} We have added a new subsection (2.3.1) to explain in more details about the ESBMC's architecture. In addition, we have now added two new images to improve readability of our manuscript: a sketch of the ESBMC's architecture and a draft that explains the connection of CUDA operational model into the verification process, which is performed by ESBMC. We have also included the CUDA operational model organization to emphasize which CUDA libraries are actually supported by ESBMC-GPU.}
\end{quote}

{\bf(5)} The reference section can be considerably improved. For instance, seminal works on ?Bounded Model Checking? and ?Satisfiability Module Theories? (section 1) should be referenced. The authors should also include references for the SMT solvers listed in subsection 4.2.

\begin{quote}
\textcolor{blue}{\textbf{Response:} We have now included the following references for Bounded Model Checking, Satisfiability Modulo Theories, and the respective SMT solvers that we currently cite in the paper:} 
\end{quote}
\textcolor{blue}{A. Biere. Bounded Model Checking. Handbook of Satisfiability. IOS Press 2009; 457--481.}

\textcolor{blue}{Barrett C, Sebastiani R, Seshia S, Tinelli C. Satisfiability Modulo Theories. Handbook of Satisfiability. IOS Press 2009; 825--885.}

\textcolor{blue}{Moura L, Bjorner N. Z3: An Efficient SMT Solver. TACAS 2008; 337--340.}

\textcolor{blue}{Brummayer R, Biere A. Boolector: An Efficient SMT Solver for Bit-Vectors and Arrays. TACAS 2009; 174--177.}

\textcolor{blue}{B. Dutertre. Yices 2.2. CAV 2014; 737--744.}

\textcolor{blue}{Cimatti A, Griggio A, Schaafsma B, Sebastiani R. The MathSAT5 SMT Solver. TACAS 2013; 93--107.}

\textcolor{blue}{Deters M, Reynolds A, King T, Barrett C, Tinelli C. A tour of CVC4: How it works, and how to use it. FMCAD 2014; 7.}


{\bf(6)} The legends for tables I e II should explain what the numbers in the tables mean.

\begin{quote}
\textcolor{blue}{\textbf{Response:} We have now thoroughly explained in each legend the data from Tables I and II.}
\end{quote}

\end{quote}

%---------------------------------------------------------------------------

\newpage
\subsection*{Reviewer \#3 comments followed by the authors' answers:}
\begin{quote}

{\bf Comments to the Author}

The paper proposes a context-bounded model checking for CUDA programs. In particular,
the paper leverages on the advances of satisfiability modulo theory (SMT). Compared
to previously proposed approaches, this work could verify more properties in CUDA
programs chosen from a standard pool of benchmarks. It also shows the application of
monotonic partial order reduction (MPOR) in verifying GPU programs. 
The paper is oriented towards a tool. However, such publications are encouraged for the journal. 
Specifically, the work shows the application of several well-known
model checking techniques, such as SAT-based and explicit state-space based model
checking, for CUDA programs. The paper does not propose any novel technique. However,
it has designed a tool, which is evaluated well and it has also been made available
in public. I appreciate such effort by authors.

\begin{quote}
\textcolor{blue}{\textbf{Response:} We appreciate the reviewer's comments. We have emphasized four major contributions of our manuscript in Section 1. We agree with the reviewer that SMT-based context-bounded model checking is not a novel technique (it has been around for nearly one decade), but we have not seen yet its application to verify CUDA programs in the literature. Additionally, we have extended the original MPOR algorithm implemented in ESBMC, in order to identify array accesses that are independent in CUDA programs (which is very common in GPU applications); this extension has led to significant performance improvements in ESBMC-GPU, as described in the experimental evaluation of our manuscript.}
\end{quote}

{\bf Reviews:}

{\bf(1)} The organization of the paper is somewhat very informal. The current presentation
mostly revolves around showing code snippets. However, there is a lack of formal
presentation, especially for a paper that discusses model checking and verification.

\begin{quote}
\textcolor{blue}{\textbf{Response:} In order to improve the organization of our manuscript, we have tackled its informality by replacing code snippets by (detailed) algorithms that reliably represent the CUDA operational model. We believe this alternative form of presentation has also improved the readability of our manuscript. Note that we have described pre- and postconditions of the algorithms, where possible, in order to ensure the correct operation of the CUDA libraries' real behavior and also to consequently improve the manuscript's readability and trustfulness. These pre- and postconditions formally ensure the CUDA libraries semantics by means of assertions properly inserted into the code.}
\end{quote}

{\bf(2)} It would be good to highlight, very concretely in a separate section, the reasons
for the tool being more effective compared to any other existing verifiers for
CUDA programs. Is it due to the operational model being rich for ESBMC-GPU? Is it
due to the encoding via SMT solvers? I would suggest to take a simple example of
CUDA programs and show (with sufficient detail) the reason for ESBMC-GPU being
more effective than other existing tools. Whereas the evaluation is promising, but
we need a general idea of the reason for such positive evaluation.

\begin{quote}
\textcolor{blue}{\textbf{Response:} We have included a new subsection at the end of Section 4.3. about the ``Experimental Results'', which properly describes the ESBMC-GPU effectiveness over other existing GPU verifiers. Additionally, we describe a simple example in Section 3.1.3. ``Illustrative Example'', which shows the reason for ESBMC-GPU being more effective than other existing verification tools.} 
\end{quote}

{\bf(3)} Authors use ``pthread\_create'' to use different threads for CUDA programs. Whereas
CUDA threads are different in the sense that they operate in lockstep fashion
within a warp (i.e. the SIMD feature of GPU). It is unclear whether warp-level
threads in GPU can be simulated by ``pthread''. Authors should provide sufficient
justification that such a transformation via pthread does not affect the soundness
of the verifier.

\begin{quote}
\textcolor{blue}{\textbf{Response:} Note that in our present approach, each CUDA thread is actually mapped to a thread using the internal representation of ESBMC (via Pthread library). In ESBMC, a thread $t$ is a sublist of commands between \emph{begin\_thread} and \emph{end\_thread}, which represent just scoping constructs and do not contribute to the expansion of the RT (described in Section 2.3). Threads are created via asynchronous procedure calls (\emph{start\_thread}), which return an integer that can be used as thread identifier for synchronization (\emph{join\_thread}); hence, dynamic thread creation is allowed. The thread representation of ESBMC follows a similar approach to the official CUDA scheduler. 
One feature of CUDA related to thread synchronization supported by ESBMC-GPU is the \emph{\tt \_\_syncthreads()} intrinsic function, which specifies synchronization points in the GPU kernel. Such alternative guarantees that all threads in a certain block wait before any of them is allowed to proceed. As described in Algorithm 7, we implement this feature in our operational model using Pthread functions. First of all, a $count$ global variable is initialized to control how many times the \emph{\tt syncthreads} function is actually called. In its first call, a mutex is initialized and a condition variable is set up (steps from $2$ to $5$ of Algorithm $7$). Then, on each subsequent call, the $count$ variable is incremented (step $6$) and the calling thread is put on hold until it receives a signal (step $8$). When all GPU threads are on hold, the $pthread\_cond\_signal$ function sends a signal to all threads waiting on a specific condition variable (step $9$) and the mutex is then unlocked (step $10$). We address this important discussion in Section 3.2.1. about ``Thread Synchronization''. }
\end{quote}


{\bf(4)} Since the approach described in the paper is quite informal, I could not see
any proof regarding the soundness of the operational model. I do not think it
is straightforward. Authors could try to provide some sketches of proof for
the soundness.

\begin{quote}
\textcolor{blue}{\textbf{Response:} The usefulness of our approach relies on the fact that COM correctly represents the original CUDA libraries. In that sense, all developed COM modules were manually verified and exhaustively compared to the original ones to ensure the same behavior; they all contain precondition and postcondition, where possible, to ensure that a predicate holds before and after the execution of a given function, respectively. Additionally, although COM is a new implementation, it consists in (reliably) constructing a simplified model of the related CUDA libraries, using the same language and by means of the original code and documentation (pre- and postconditions are formally verified by the model checker using assertions within the code itself), which thus tends to decrease the resulting number of errors. Additionally, the behavior of the CUDA libraries functions are represented in C/C$++$ programming languages using native functions, which are already supported by ESBMC ({\it e.g.}, \textit{malloc}, \textit{free}, \textit{assert}). The soundness proof for those native functions implemented in ESBMC can be found in Cordeiro {\it et al.}. Conformance testing regarding operational models is commonly employed in practice; however, that option is not available in the present case, albeit it is an interesting possibility for future work. We discuss this important issue raised by the reviewer, at the end of Section 3.1. ``Operational Models for CUDA Libraries'' and Section 5. ``Conclusions''.}
\end{quote}

{\bf(5)} Authors should provide some summary of these benchmarks in the paper. I know
that the benchmarks are available in the website. However, providing some
salient features of these benchmarks in the paper will help improve the quality.

\begin{quote}
\textcolor{blue}{\textbf{Response:} Note that we used benchmarks from a variety of sources to evaluate ESBMC-GPU's precision and performance, which include CUDA benchmark suites to check basic functions that are commonly used by CUDA applications. Our benchmarks test suite comprises of 20 CUDA kernels from NVIDIA GPU Computing SDK v2.0, 20 CUDA kernels from Microsoft C++ AMP Sample Projects, and 104 CUDA programs that explore a wide range of CUDA functionalities. Although some of these CUDA benchmarks do not implement any real CUDA application, we used them to analyze to which extent ESBMC-GPU is able to handle and detect errors; in particular, those benchmarks have been previously used for comparing the performance and precision of different GPU verifiers. It is worth notice that the benchmarks related to OpenCL were not applied to our experimental evaluation, once ESBMC-GPU does not support it yet. We briefly describe the benchmarks in the first two paragraphs of Section 4.1. about the ``Experimental Setup''.}
\end{quote}

{\bf(6)} A minor comment: Why do we even need Figure 11? I think it's trivial, unless it
is expanded enough with some details of two-thread analysis.

\begin{quote}
\textcolor{blue}{\textbf{Response:} We have modified this specific figure and included more details about the two-thread analysis, as suggested by the reviewer.}
\end{quote}

\end{quote}
%-----------------------------------------------------------------

\label{LastPage}

% \printbibliography

\end{document} 